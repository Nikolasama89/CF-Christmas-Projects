package gr.aueb.cf.project2;

/**
 * Παρολο που δεν ειχα καταλαβει την ασκηση στην αρχη με λιγο ψαξιμο, με βαση το hint που δωσατε,
 * βρηκα οτι μπορει να λυθει χρησιμοποιωντας τον αλγοριθμο του Kadane.
 * Ξεκιναμε παιρνοντας οτι το πρωτο στοιχειο nums[0] του πινακα ειναι το μεγιστο αθροισμα.
 * Με μια for παιρνουμε το καθε στοιχειο του πινακα και σε καθε βημα προσθετουμε στον υποπινακα.
 * Σε κάθε βήμα αποφασίζουμε αν Θα συνεχίσουμε να προσθέτουμε το τρέχον στοιχείο στον προηγούμενο υποπίνακα η
 * θα ξεκινήσουμε έναν νέο υποπίνακα από το τρέχον στοιχείο.
 * Αυτο γινεται με το currentMax=max(currentMax+nums[i],nums[i])
 * Η γραμμικοτητα ειναι O(n) γτ κανουμε ενα μονο περασμα στον πινακα σε αντιθεση με την brute force προσεγγιση
 * που θα ηταν Ο(n**2)
 * Στην brute force θα επρεπε να εχουμε 2 for loop. Στιο πρωτο for θα ειχαμε i = 0 και μεσα θα ειχαμε ακομα ενα for loop
 * j = i. θα προσθεταμε το καθε στοιχειο και θα ανανεωναμε τα currentMax και globalMax.
 * Αυτή η προσέγγιση έχει πολυπλοκότητα O(n**2), επειδή κάθε στοιχείο εξετάζεται με όλα τα επόμενα στοιχεία.
 *
 * Να τονισω οτι η κατανοηση του αλγοριθμου εγινε με διαφορα βιντεα και αρθρα που βρηκα στο διαδικτυο με βαση το hint
 * που δωσατε.
 * Καλη χρονια να εχουμε με υγεια!
 *
 */

public class KadaneAlgorithm {
    static int currentMax;
    static int globalMax;

    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};

        int maxSum = findMaxSubArray(nums);

        System.out.println("To μέγιστο άθροισμα ειναι: " + maxSum);
    }

    public static int findMaxSubArray(int[] nums) {
        // Δηλωνουμε ως μεγιστα το πρωτο στοιχειο του πινακα
        currentMax = nums[0];
        globalMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            //Υπολογιζουμε το τοπικο
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            // Ανανεωνουμε το γενικο
            globalMax = Math.max(globalMax, currentMax);
        }
        return globalMax;
    }
}
